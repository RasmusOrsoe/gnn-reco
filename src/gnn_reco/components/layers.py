from typing import Callable, Optional, Sequence

from torch.functional import Tensor

from torch_geometric.nn import EdgeConv
from torch_geometric.nn.pool import knn_graph
from torch_geometric.typing import Adj


class DynEdgeConv(EdgeConv):
    def __init__(
        self,
        nn: Callable,
        aggr: str = 'max',
        nb_neighbors: int = 8,
        features_subset: Optional[Sequence] = None,
        **kwargs,
    ):
        # Check(s)
        if features_subset is None:
            features_subset = slice(None)  # Use all features
        assert isinstance(features_subset, (list, slice))

        # Base class constructor
        super().__init__(nn=nn, aggr=aggr, **kwargs)

        # Additional member variables
        self.nb_neighbors = nb_neighbors
        self.features_subset = features_subset

    def forward(self, x: Tensor, edge_index: Adj, batch: Optional[Tensor] = None) -> Tensor:
        # Standard EdgeConv forward pass
        x = super().forward(x, edge_index)

        # Recompute adjacency
        edge_index = knn_graph(
            x=x[:, self.features_subset],
            k=self.nb_neighbors,
            batch=batch,
        ).to(x.device)

        return x, edge_index
